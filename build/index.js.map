{"version":3,"sources":["webpack://EvalExp/webpack/universalModuleDefinition","webpack://EvalExp/./src/CharacterAccessor.js","webpack://EvalExp/./src/tokens/AbstractToken.js","webpack://EvalExp/./src/tokens/GroupToken.js","webpack://EvalExp/./src/tokens/RootToken.js","webpack://EvalExp/./src/tokens/NumberToken.js","webpack://EvalExp/./src/tokens/ValueToken.js","webpack://EvalExp/./src/tokens/LeftRightOperatorToken.js","webpack://EvalExp/./src/tokens/OperatorToken.js","webpack://EvalExp/./src/tokens/MultiplicationToken.js","webpack://EvalExp/./src/tokens/transformModifier/addMultiplicationOperator.js","webpack://EvalExp/./src/tokens/BracketToken.js","webpack://EvalExp/./src/tokens/ArgumentToken.js","webpack://EvalExp/./src/tokens/VariableToken.js","webpack://EvalExp/./src/tokens/LeftNotNullRightOperatorToken.js","webpack://EvalExp/./src/tokens/AdditionToken.js","webpack://EvalExp/./src/tokens/DivisionToken.js","webpack://EvalExp/./src/tokens/SubtractionToken.js","webpack://EvalExp/./src/lexer.js","webpack://EvalExp/./src/index.js","webpack://EvalExp/./src/transformer.js","webpack://EvalExp/webpack/bootstrap","webpack://EvalExp/webpack/startup","webpack://EvalExp/webpack/runtime/define property getters","webpack://EvalExp/webpack/runtime/hasOwnProperty shorthand","webpack://EvalExp/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","CharacterAccessor","rawString","index","charactersRegexp","replace","length","AbstractToken","iterator","SyntaxError","left","right","parent","TokenType","registeredTokenTypes","push","character","ApplicableToken","find","isApplicable","addGlobalChild","getIterator","moveLeft","value","getValue","getParent","isChildAllowed","getApplicable","applicableToken","getApplicableToken","setRight","setRoot","getRoot","setLeft","setParent","addChild","parse","GroupToken","props","children","child","removeChild","filter","declarations","getChild","evaluate","RootToken","globalChildren","parseUp","NumberToken","test","isFloatingPoint","nextValue","getNextValue","setValue","parseLeft","Number","LeftRightOperatorToken","addChildAtIndex","operand","getLeft","leftOperandSibling","getRight","rightOperandSibling","leftOperand","getLeftOperand","transformLeftOperand","setLeftChild","rightOperand","getRightOperand","transformRightOperand","setRightChild","MultiplicationToken","getLeftChild","getRightChild","addMultiplicationOperator","token","multiplicationToken","BracketToken","moveNext","ArgumentToken","includes","VariableToken","name","isFunction","parseArgument","argumentToken","setName","getName","parseName","parseArguments","variableName","variable","getNumChildren","evaluatedArguments","getChildren","map","apply","LeftNotNullRightOperatorToken","numberToken","AdditionToken","DivisionToken","SubtractionToken","BaseToken","EvalExp","expression","rootToken","evalExp","orderedOperatorTypes","tokenList","stringExpression","removeCharacters","lexer","getGlobalList","forEach","operatorType","transform","parseIfNotParsed","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EvalExp\"] = factory();\n\telse\n\t\troot[\"EvalExp\"] = factory();\n})(this, function() {\nreturn ","export default class CharacterAccessor {\n    constructor(rawString) {\n        this.rawString = rawString;\n        this.index = -1;\n    }\n\n    removeCharacters(charactersRegexp) {\n        this.rawString = this.rawString.replace(charactersRegexp, \"\");\n    }\n\n    getValue() {\n        return this.rawString[this.index];\n    }\n\n    getNextValue() {\n        return this.rawString[this.index + 1];\n    }\n\n    getPrevValue() {\n        return this.rawString[this.index - 1];\n    }\n\n    moveLeft() {\n        if (this.index + 1 >= this.rawString.length) {\n            return null;\n        } else {\n            this.index++;\n            return true;\n        }\n    }\n\n    moveRight() {\n        if (this.index - 1 < 0) {\n            return null;\n        } else {\n            this.index--;\n            return true;\n        }\n    }\n}\n","export default class AbstractToken {\n    static registeredTokenTypes = [];\n\n    static registerTokenType(TokenType) {\n        AbstractToken.registeredTokenTypes.push(TokenType);\n    }\n\n    static getApplicable(character) {\n        const ApplicableToken = AbstractToken.registeredTokenTypes.find(TokenType =>\n            TokenType.isApplicable(character)\n        );\n        if (ApplicableToken) {\n            return ApplicableToken;\n        } else {\n            throw SyntaxError(`No applicable token type for ${character}`);\n        }\n    }\n\n    static isApplicable(character) {\n        return false;\n    }\n\n    constructor(iterator) {\n        if (new.target === AbstractToken) {\n            throw SyntaxError(\"AbstractToken is abstract class\");\n        }\n        this.iterator = iterator;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n        this.root = null;\n    }\n\n    getIterator() {\n        return this.iterator;\n    }\n\n    setLeft(left) {\n        this.left = left;\n    }\n\n    getLeft() {\n        return this.left;\n    }\n\n    setRight(right) {\n        this.right = right;\n    }\n\n    getRight() {\n        return this.right;\n    }\n\n    setParent(parent) {\n        this.parent = parent;\n    }\n\n    getParent() {\n        return this.parent;\n    }\n\n    setRoot(root) {\n        this.root = root;\n        this.root.addGlobalChild(this);\n    }\n\n    getRoot() {\n        return this.root;\n    }\n\n    isChildAllowed() {\n        return true;\n    }\n\n    getApplicableToken() {\n        if (this.getIterator().moveLeft()) {\n            const value = this.getIterator().getValue();\n            if (value && (!this.getParent() || this.getParent().isChildAllowed())) {\n                const ApplicableTokenType = AbstractToken.getApplicable(value);\n                const applicableToken = new ApplicableTokenType(this.getIterator());\n                return applicableToken;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    parseLeft() {\n        const applicableToken = this.getApplicableToken();\n        if (applicableToken) {\n            this.setRight(applicableToken);\n            applicableToken.setRoot(this.getRoot());\n            applicableToken.setLeft(this);\n            applicableToken.setParent(this.getParent());\n            this.getParent().addChild(applicableToken);\n            applicableToken.parse();\n        }\n    }\n\n    parse() {}\n\n    transform() {\n    }\n\n    evaluate() {}\n}\n","import AbstractToken from \"./AbstractToken\";\n\n\nexport default class GroupToken extends AbstractToken{\n    constructor(props) {\n        super(props);\n        this.children = [];\n    }\n\n    addChild(child) {\n        this.children.push(child);\n    }\n\n    removeChild(removeChild) {\n        this.children = this.children.filter(child => child !== removeChild);\n    }\n\n    addChildAtIndex(child, index) {\n        this.children[index] = child;\n    }\n\n    getChild(index) {\n        return this.children[index];\n    }\n\n    getNumChildren() {\n        return this.children.length;\n    }\n\n    getChildren() {\n        return this.children;\n    }\n\n    parseUp() {\n        const applicableToken = this.getApplicableToken();\n        if(applicableToken) {\n            this.addChild(applicableToken);\n            applicableToken.setRoot(this.getRoot());\n            applicableToken.setParent(this);\n            applicableToken.parse();\n        }\n    }\n\n    evaluate(declarations) {\n        return this.getChild(0).evaluate(declarations);\n    }\n}","import GroupToken from \"./GroupToken\";\n\n\nexport default class RootToken extends GroupToken {\n\n    constructor(iterator) {\n        super(iterator);\n        this.globalChildren = [];\n        this.setRoot(this);\n    }\n\n    setRoot(root) {\n        this.root = root;\n    }\n\n    addGlobalChild(child) {\n        this.globalChildren.push(child);\n    }\n\n    getGlobalList(index) {\n        return this.globalChildren;\n    }\n\n    parse() {\n        this.parseUp();\n    }\n}","import ValueToken from \"./ValueToken\";\n\nexport default class NumberToken extends ValueToken {\n\n    static isApplicable(character) {\n        return /^[0-9]$/i.test( character );\n    }\n\n    parse() {\n        let isFloatingPoint = false;\n        while(true) {\n            const nextValue = this.getIterator().getNextValue();\n            if(/^[0-9.]$/i.test( nextValue )) {\n                if(nextValue === \".\") {\n                    if(isFloatingPoint) {\n                        throw SyntaxError(\"More than one floating point in number\");\n                    } else {\n                        isFloatingPoint = true;\n\n                    }\n                }\n                this.getIterator().moveLeft();\n                this.setValue(this.getValue() + \"\" + nextValue);\n            } else {\n                break;\n            }\n        }\n        this.parseLeft();\n    }\n\n    evaluate() {\n        return Number(this.getValue());\n    }\n}","import AbstractToken from \"./AbstractToken\";\n\nexport default class ValueToken extends AbstractToken {\n    constructor(iterator) {\n        super(iterator);\n        this.value = iterator.getValue();\n    }\n\n    setValue(value) {\n        this.value = value;\n    }\n\n    getValue() {\n        return this.value;\n    }\n\n    parse() {\n        this.parseLeft();\n    }\n}\n","import OperatorToken from \"./OperatorToken\";\n\nexport default class LeftRightOperatorToken extends OperatorToken {\n\n    setLeftChild(child) {\n        this.addChildAtIndex(child, 0);\n    }\n\n    getLeftChild() {\n        return this.getChild(0);\n    }\n\n    setRightChild(child) {\n        this.addChildAtIndex(child, 1);\n    }\n\n    getRightChild() {\n        return this.getChild(1);\n    }\n\n    getLeftOperand() {\n        const operand = this.getLeft();\n        if(!operand) {\n            throw SyntaxError(\"Left operand is required\");\n        }\n        return operand;\n    }\n\n    transformLeftOperand(operand) {\n        const leftOperandSibling = operand.getLeft();\n        if(operand.getParent()) {\n            operand.getParent().removeChild(operand);\n        }\n        operand.setParent(this);\n        operand.setLeft(null);\n        operand.setRight(null);\n        if(leftOperandSibling) {\n            leftOperandSibling.setRight(this);\n        }\n    }\n\n    getRightOperand() {\n        const operand = this.getRight();\n        if(!operand) {\n            throw SyntaxError(\"Right operand is required\");\n        }\n        return operand;\n    }\n\n    transformRightOperand(operand) {\n        const rightOperandSibling = operand.getRight();\n        if(operand.getParent()) {\n            operand.getParent().removeChild(operand);\n        }\n        operand.getParent().removeChild(operand);\n        operand.setParent(this);\n        operand.setLeft(null);\n        operand.setRight(null);\n        if(rightOperandSibling) {\n            rightOperandSibling.setLeft(this);\n        }\n    }\n\n    transform() {\n        const leftOperand = this.getLeftOperand();\n        this.transformLeftOperand(leftOperand);\n        this.setLeftChild(leftOperand);\n        const rightOperand = this.getRightOperand();\n        this.transformRightOperand(rightOperand);\n        this.setRightChild(rightOperand);\n    }\n}","import GroupToken from \"./GroupToken\";\n\n\nexport default class OperatorToken extends GroupToken {\n    parse() {\n        this.parseLeft();\n    }\n}","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\n\n\nexport default class MultiplicationToken extends LeftRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"*\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) * this.getRightChild().evaluate(declarations);\n    }\n}","import NumberToken from \"../NumberToken\";\nimport MultiplicationToken from \"../MultiplicationToken\";\n\nexport default function addMultiplicationOperator(token) {\n    const operand = token.getLeft();\n    if (operand && operand instanceof NumberToken) {\n        const multiplicationToken = new MultiplicationToken(token.getIterator());\n        operand.setRight(multiplicationToken);\n        multiplicationToken.setLeft(operand);\n        token.setLeft(multiplicationToken);\n        multiplicationToken.setRight(token);\n        multiplicationToken.setParent(token.getParent());\n        token.getParent().addChild(multiplicationToken);\n        multiplicationToken.setRoot(token.getRoot());\n    }\n}\n","import GroupToken from \"./GroupToken\";\nimport addMultiplicationOperator from \"./transformModifier/addMultiplicationOperator\";\n\nexport default class BracketToken extends GroupToken {\n    static isApplicable(character) {\n        return character === \"(\";\n    }\n\n    isChildAllowed() {\n        return this.getIterator().getValue() !== \")\";\n    }\n\n    transform() {\n        addMultiplicationOperator(this);\n    }\n\n    parse() {\n        const nextValue = this.getIterator().getNextValue();\n        // TODO I think we should not accept empty brackets  like 2 + ()*3 we should throw error in this condition\n        if (nextValue === \")\") {\n            this.getIterator().moveNext();\n            this.parseLeft();\n        }\n        this.parseUp();\n        this.parseLeft();\n    }\n}\n","import GroupToken from \"./GroupToken\";\n\nexport default class ArgumentToken extends GroupToken {\n    static isApplicable(character) {\n        return character === \"(\";\n    }\n\n    isChildAllowed() {\n        return ![\")\", \",\"].includes(this.getIterator().getValue());\n    }\n\n    parse() {\n        this.parseUp();\n    }\n}\n","import GroupToken from \"./GroupToken\";\nimport addMultiplicationOperator from \"./transformModifier/addMultiplicationOperator\";\nimport BracketToken from \"./BracketToken\";\nimport ArgumentToken from \"./ArgumentToken\";\n\nexport default class VariableToken extends GroupToken {\n    static isApplicable(character) {\n        return /^[a-z]$/i.test(character);\n    }\n\n    constructor(iterator) {\n        super(iterator);\n        this.name = iterator.getValue();\n        this.isFunction = false;\n    }\n\n    setName(name) {\n        this.name = name;\n    }\n\n    getName() {\n        return this.name;\n    }\n\n    parseArguments() {\n        const nextValue = this.getIterator().getNextValue();\n        if (nextValue === \"(\") {\n            this.getIterator().moveLeft();\n            this.isFunction = true;\n            const nextValue = this.getIterator().getNextValue();\n            if (nextValue === \")\") {\n                this.getIterator().moveLeft();\n            } else {\n                while (true) {\n                    this.parseArgument();\n                    if (this.getIterator().getValue() !== \",\") {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    parseArgument() {\n        const argumentToken = new ArgumentToken(this.getIterator());\n        this.addChild(argumentToken);\n        argumentToken.setRoot(this.getRoot());\n        argumentToken.setParent(this);\n        argumentToken.parse();\n    }\n\n    parseName() {\n        while (true) {\n            const nextValue = this.getIterator().getNextValue();\n            if (/^[a-z0-9]$/i.test(nextValue)) {\n                this.getIterator().moveLeft();\n                this.setName(this.getName() + \"\" + nextValue);\n            } else {\n                break;\n            }\n        }\n    }\n\n    parse() {\n        this.parseName();\n        this.parseArguments();\n        this.parseLeft();\n    }\n\n    transform() {\n        /*\n        const rightOperand = this.getRight();\n        if (rightOperand && rightOperand instanceof BracketToken) {\n            this.isFunction = true;\n            const rightOperandSibling = rightOperand.getRight();\n            if(rightOperand.getParent()) {\n                rightOperand.getParent().removeChild(rightOperand);\n            }\n            rightOperand.getParent().removeChild(rightOperand);\n            rightOperand.setParent(this);\n            rightOperand.setLeft(null);\n            rightOperand.setRight(null);\n            if(rightOperandSibling) {\n                rightOperandSibling.setLeft(this);\n            }\n            this.addChild(rightOperand);\n        }\n        */\n        addMultiplicationOperator(this);\n    }\n\n    evaluate(declarations) {\n        const variableName = this.getName();\n        if (!declarations || !(variableName in declarations)) {\n            throw SyntaxError(`Expected variable is not defined ${variableName}`);\n        }\n        const variable = declarations[variableName];\n        if (typeof variable === \"function\") {\n            if (variable.length !== this.getNumChildren()) {\n                throw SyntaxError(\n                    `Expected number of arguments ${\n                        variable.length\n                    } but got ${this.getNumChildren()}`\n                );\n            }\n            const evaluatedArguments = this.getChildren().map(child =>\n                child.evaluate(declarations)\n            );\n            return Number(variable.apply({}, evaluatedArguments));\n        }\n        if (this.isFunction) {\n            throw SyntaxError(`Expected variable but got function ${variableName}`);\n        }\n        return Number(variable);\n    }\n}\n","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\nimport NumberToken from \"./NumberToken\";\n\nexport default class LeftNotNullRightOperatorToken extends LeftRightOperatorToken {\n\n    getLeftOperand() {\n        const operand = this.getLeft();\n        if(!operand) {\n            const numberToken = new NumberToken(this.getIterator());\n            numberToken.setValue(0);\n            return numberToken;\n        }\n        return operand;\n    }\n}","import LeftNotNullRightOperatorToken from \"./LeftNotNullRightOperatorToken\";\n\nexport default class AdditionToken extends LeftNotNullRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"+\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) + this.getRightChild().evaluate(declarations);\n    }\n}","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\n\n\nexport default class DivisionToken extends LeftRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"/\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) / this.getRightChild().evaluate(declarations);\n    }\n}","import LeftNotNullRightOperatorToken from \"./LeftNotNullRightOperatorToken\";\n\n\nexport default class SubtractionToken extends LeftNotNullRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"-\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) - this.getRightChild().evaluate(declarations);\n    }\n}","import CharacterAccessor from \"./CharacterAccessor\";\nimport BaseToken from \"./tokens/AbstractToken\";\nimport RootToken from \"./tokens/RootToken\";\nimport NumberToken from \"./tokens/NumberToken\";\nimport VariableToken from \"./tokens/VariableToken\";\nimport BracketToken from \"./tokens/BracketToken\";\nimport AdditionToken from \"./tokens/AdditionToken\";\nimport DivisionToken from \"./tokens/DivisionToken\";\nimport MultiplicationToken from \"./tokens/MultiplicationToken\";\nimport SubtractionToken from \"./tokens/SubtractionToken\";\n\nBaseToken.registerTokenType(NumberToken);\nBaseToken.registerTokenType(VariableToken);\nBaseToken.registerTokenType(AdditionToken);\nBaseToken.registerTokenType(SubtractionToken);\nBaseToken.registerTokenType(DivisionToken);\nBaseToken.registerTokenType(MultiplicationToken);\nBaseToken.registerTokenType(BracketToken);\n\nexport default function lexer(stringExpression) {\n    const iterator = new CharacterAccessor(stringExpression);\n    iterator.removeCharacters(/\\s/g);\n    const rootToken = new RootToken(iterator);\n    rootToken.parse();\n    return rootToken;\n}\n","import lexer from \"./lexer\";\nimport transformer from \"./transformer\";\n\nclass EvalExp {\n    static evaluate(expression, declarations = {}) {\n        const evalExp = new EvalExp(expression);\n        return evalExp.evaluate(declarations);\n    }\n\n    constructor(expression) {\n        this.expression = expression;\n        this.rootToken = null;\n    }\n\n    parse() {\n        this.rootToken = lexer(this.expression);\n        transformer(this.rootToken);\n    }\n\n    getParsedTree() {\n        this.parseIfNotParsed();\n        return this.rootToken;\n    }\n\n    evaluate(declarations = {}) {\n        this.parseIfNotParsed();\n        return this.rootToken.evaluate(declarations);\n    }\n\n    parseIfNotParsed() {\n        if (!this.rootToken) {\n            this.parse();\n        }\n    }\n}\nfunction evaluate(expression, declarations) {\n    return EvalExp.evaluate(expression, declarations);\n}\n\nexport default EvalExp;\nexport { EvalExp, evaluate };\n","import MultiplicationToken from \"./tokens/MultiplicationToken\";\nimport DivisionToken from \"./tokens/DivisionToken\";\nimport AdditionToken from \"./tokens/AdditionToken\";\nimport SubtractionToken from \"./tokens/SubtractionToken\";\nimport VariableToken from \"./tokens/VariableToken\";\nimport BracketToken from \"./tokens/BracketToken\";\n\nexport default function transformer(rootToken) {\n    const orderedOperatorTypes = [\n        BracketToken,\n        VariableToken,\n        MultiplicationToken,\n        DivisionToken,\n        AdditionToken,\n        SubtractionToken\n    ];\n\n    const tokenList = rootToken.getGlobalList();\n    orderedOperatorTypes.forEach(operatorType => {\n        tokenList.forEach(token => {\n            if (token instanceof operatorType) {\n                token.transform();\n            }\n        });\n    });\n    return rootToken;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(426);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}