{"version":3,"sources":["webpack://EvalExp/webpack/universalModuleDefinition","webpack://EvalExp/./src/CharacterAccessor.js","webpack://EvalExp/./src/tokens/AbstractToken.js","webpack://EvalExp/./src/tokens/GroupToken.js","webpack://EvalExp/./src/tokens/RootToken.js","webpack://EvalExp/./src/tokens/NumberToken.js","webpack://EvalExp/./src/tokens/ValueToken.js","webpack://EvalExp/./src/tokens/LeftRightOperatorToken.js","webpack://EvalExp/./src/tokens/OperatorToken.js","webpack://EvalExp/./src/tokens/MultiplicationToken.js","webpack://EvalExp/./src/tokens/transformModifier/addMultiplicationOperator.js","webpack://EvalExp/./src/tokens/BracketToken.js","webpack://EvalExp/./src/tokens/ArgumentToken.js","webpack://EvalExp/./src/tokens/VariableToken.js","webpack://EvalExp/./src/tokens/LeftNotNullRightOperatorToken.js","webpack://EvalExp/./src/tokens/AdditionToken.js","webpack://EvalExp/./src/tokens/DivisionToken.js","webpack://EvalExp/./src/tokens/SubtractionToken.js","webpack://EvalExp/./src/lexer.js","webpack://EvalExp/./src/index.js","webpack://EvalExp/./src/transformer.js","webpack://EvalExp/webpack/bootstrap","webpack://EvalExp/webpack/startup","webpack://EvalExp/webpack/runtime/define property getters","webpack://EvalExp/webpack/runtime/hasOwnProperty shorthand","webpack://EvalExp/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","CharacterAccessor","rawString","index","charactersRegexp","replace","length","AbstractToken","iterator","SyntaxError","left","right","parent","TokenType","registeredTokenTypes","push","character","ApplicableToken","find","isApplicable","addGlobalChild","getIterator","moveLeft","value","getValue","getParent","isChildAllowed","getApplicable","applicableToken","getApplicableToken","setRight","setRoot","getRoot","setLeft","setParent","addChild","parse","GroupToken","props","children","child","removeChild","filter","declarations","getChild","evaluate","RootToken","globalChildren","parseUp","NumberToken","test","isFloatingPoint","nextValue","getNextValue","setValue","parseLeft","Number","LeftRightOperatorToken","addChildAtIndex","operand","getLeft","leftOperandSibling","getRight","rightOperandSibling","leftOperand","getLeftOperand","transformLeftOperand","setLeftChild","rightOperand","getRightOperand","transformRightOperand","setRightChild","MultiplicationToken","getLeftChild","getRightChild","addMultiplicationOperator","token","multiplicationToken","BracketToken","ArgumentToken","includes","VariableToken","name","isFunction","parseArgument","argumentToken","setName","getName","parseName","parseArguments","variableName","variable","getNumChildren","evaluatedArguments","getChildren","map","apply","LeftNotNullRightOperatorToken","numberToken","AdditionToken","DivisionToken","SubtractionToken","BaseToken","EvalExp","expression","rootToken","evalExp","orderedOperatorTypes","tokenList","stringExpression","removeCharacters","lexer","getGlobalList","forEach","operatorType","transform","parseIfNotParsed","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"EvalExp\"] = factory();\n\telse\n\t\troot[\"EvalExp\"] = factory();\n})(this, function() {\nreturn ","export default class CharacterAccessor {\n    constructor(rawString) {\n        this.rawString = rawString;\n        this.index = -1;\n    }\n\n    removeCharacters(charactersRegexp) {\n        this.rawString = this.rawString.replace(charactersRegexp, \"\");\n    }\n\n    getValue() {\n        return this.rawString[this.index];\n    }\n\n    getNextValue() {\n        return this.rawString[this.index + 1];\n    }\n\n    getPrevValue() {\n        return this.rawString[this.index - 1];\n    }\n\n    moveLeft() {\n        if (this.index + 1 >= this.rawString.length) {\n            return null;\n        } else {\n            this.index++;\n            return true;\n        }\n    }\n\n    moveRight() {\n        if (this.index - 1 < 0) {\n            return null;\n        } else {\n            this.index--;\n            return true;\n        }\n    }\n}\n","export default class AbstractToken {\n    static registeredTokenTypes = [];\n\n    static registerTokenType(TokenType) {\n        AbstractToken.registeredTokenTypes.push(TokenType);\n    }\n\n    static getApplicable(character) {\n        const ApplicableToken = AbstractToken.registeredTokenTypes.find(TokenType =>\n            TokenType.isApplicable(character)\n        );\n        if (ApplicableToken) {\n            return ApplicableToken;\n        } else {\n            throw SyntaxError(`No applicable token type for ${character}`);\n        }\n    }\n\n    static isApplicable(character) {\n        return false;\n    }\n\n    constructor(iterator) {\n        if (new.target === AbstractToken) {\n            throw SyntaxError(\"AbstractToken is abstract class\");\n        }\n        this.iterator = iterator;\n        this.left = null;\n        this.right = null;\n        this.parent = null;\n        this.root = null;\n    }\n\n    getIterator() {\n        return this.iterator;\n    }\n\n    setLeft(left) {\n        this.left = left;\n    }\n\n    getLeft() {\n        return this.left;\n    }\n\n    setRight(right) {\n        this.right = right;\n    }\n\n    getRight() {\n        return this.right;\n    }\n\n    setParent(parent) {\n        this.parent = parent;\n    }\n\n    getParent() {\n        return this.parent;\n    }\n\n    setRoot(root) {\n        this.root = root;\n        this.root.addGlobalChild(this);\n    }\n\n    getRoot() {\n        return this.root;\n    }\n\n    isChildAllowed() {\n        return true;\n    }\n\n    getApplicableToken() {\n        if (this.getIterator().moveLeft()) {\n            const value = this.getIterator().getValue();\n            if (value && (!this.getParent() || this.getParent().isChildAllowed())) {\n                const ApplicableTokenType = AbstractToken.getApplicable(value);\n                const applicableToken = new ApplicableTokenType(this.getIterator());\n                return applicableToken;\n            } else {\n                return null;\n            }\n        } else {\n            return null;\n        }\n    }\n\n    parseLeft() {\n        const applicableToken = this.getApplicableToken();\n        if (applicableToken) {\n            this.setRight(applicableToken);\n            applicableToken.setRoot(this.getRoot());\n            applicableToken.setLeft(this);\n            applicableToken.setParent(this.getParent());\n            this.getParent().addChild(applicableToken);\n            applicableToken.parse();\n        }\n    }\n\n    parse() {}\n\n    transform() {\n    }\n\n    evaluate() {}\n}\n","import AbstractToken from \"./AbstractToken\";\n\n\nexport default class GroupToken extends AbstractToken{\n    constructor(props) {\n        super(props);\n        this.children = [];\n    }\n\n    addChild(child) {\n        this.children.push(child);\n    }\n\n    removeChild(removeChild) {\n        this.children = this.children.filter(child => child !== removeChild);\n    }\n\n    addChildAtIndex(child, index) {\n        this.children[index] = child;\n    }\n\n    getChild(index) {\n        return this.children[index];\n    }\n\n    getNumChildren() {\n        return this.children.length;\n    }\n\n    getChildren() {\n        return this.children;\n    }\n\n    parseUp() {\n        const applicableToken = this.getApplicableToken();\n        if(applicableToken) {\n            this.addChild(applicableToken);\n            applicableToken.setRoot(this.getRoot());\n            applicableToken.setParent(this);\n            applicableToken.parse();\n        }\n    }\n\n    evaluate(declarations) {\n        return this.getChild(0).evaluate(declarations);\n    }\n}","import GroupToken from \"./GroupToken\";\n\n\nexport default class RootToken extends GroupToken {\n\n    constructor(iterator) {\n        super(iterator);\n        this.globalChildren = [];\n        this.setRoot(this);\n    }\n\n    setRoot(root) {\n        this.root = root;\n    }\n\n    addGlobalChild(child) {\n        this.globalChildren.push(child);\n    }\n\n    getGlobalList(index) {\n        return this.globalChildren;\n    }\n\n    parse() {\n        this.parseUp();\n    }\n}","import ValueToken from \"./ValueToken\";\n\nexport default class NumberToken extends ValueToken {\n\n    static isApplicable(character) {\n        return /^[0-9]$/i.test( character );\n    }\n\n    parse() {\n        let isFloatingPoint = false;\n        while(true) {\n            const nextValue = this.getIterator().getNextValue();\n            if(/^[0-9.]$/i.test( nextValue )) {\n                if(nextValue === \".\") {\n                    if(isFloatingPoint) {\n                        throw SyntaxError(\"More than one floating point in number\");\n                    } else {\n                        isFloatingPoint = true;\n\n                    }\n                }\n                this.getIterator().moveLeft();\n                this.setValue(this.getValue() + \"\" + nextValue);\n            } else {\n                break;\n            }\n        }\n        this.parseLeft();\n    }\n\n    evaluate() {\n        return Number(this.getValue());\n    }\n}","import AbstractToken from \"./AbstractToken\";\n\nexport default class ValueToken extends AbstractToken {\n    constructor(iterator) {\n        super(iterator);\n        this.value = iterator.getValue();\n    }\n\n    setValue(value) {\n        this.value = value;\n    }\n\n    getValue() {\n        return this.value;\n    }\n\n    parse() {\n        this.parseLeft();\n    }\n}\n","import OperatorToken from \"./OperatorToken\";\n\nexport default class LeftRightOperatorToken extends OperatorToken {\n\n    setLeftChild(child) {\n        this.addChildAtIndex(child, 0);\n    }\n\n    getLeftChild() {\n        return this.getChild(0);\n    }\n\n    setRightChild(child) {\n        this.addChildAtIndex(child, 1);\n    }\n\n    getRightChild() {\n        return this.getChild(1);\n    }\n\n    getLeftOperand() {\n        const operand = this.getLeft();\n        if(!operand) {\n            throw SyntaxError(\"Left operand is required\");\n        }\n        return operand;\n    }\n\n    transformLeftOperand(operand) {\n        const leftOperandSibling = operand.getLeft();\n        if(operand.getParent()) {\n            operand.getParent().removeChild(operand);\n        }\n        operand.setParent(this);\n        operand.setLeft(null);\n        operand.setRight(null);\n        if(leftOperandSibling) {\n            leftOperandSibling.setRight(this);\n        }\n    }\n\n    getRightOperand() {\n        const operand = this.getRight();\n        if(!operand) {\n            throw SyntaxError(\"Right operand is required\");\n        }\n        return operand;\n    }\n\n    transformRightOperand(operand) {\n        const rightOperandSibling = operand.getRight();\n        if(operand.getParent()) {\n            operand.getParent().removeChild(operand);\n        }\n        operand.getParent().removeChild(operand);\n        operand.setParent(this);\n        operand.setLeft(null);\n        operand.setRight(null);\n        if(rightOperandSibling) {\n            rightOperandSibling.setLeft(this);\n        }\n    }\n\n    transform() {\n        const leftOperand = this.getLeftOperand();\n        this.transformLeftOperand(leftOperand);\n        this.setLeftChild(leftOperand);\n        const rightOperand = this.getRightOperand();\n        this.transformRightOperand(rightOperand);\n        this.setRightChild(rightOperand);\n    }\n}","import GroupToken from \"./GroupToken\";\n\n\nexport default class OperatorToken extends GroupToken {\n    parse() {\n        this.parseLeft();\n    }\n}","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\n\n\nexport default class MultiplicationToken extends LeftRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"*\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) * this.getRightChild().evaluate(declarations);\n    }\n}","import NumberToken from \"../NumberToken\";\nimport MultiplicationToken from \"../MultiplicationToken\";\n\nexport default function addMultiplicationOperator(token) {\n    const operand = token.getLeft();\n    if (operand && operand instanceof NumberToken) {\n        const multiplicationToken = new MultiplicationToken(token.getIterator());\n        operand.setRight(multiplicationToken);\n        multiplicationToken.setLeft(operand);\n        token.setLeft(multiplicationToken);\n        multiplicationToken.setRight(token);\n        multiplicationToken.setParent(token.getParent());\n        token.getParent().addChild(multiplicationToken);\n        multiplicationToken.setRoot(token.getRoot());\n    }\n}\n","import GroupToken from \"./GroupToken\";\nimport addMultiplicationOperator from \"./transformModifier/addMultiplicationOperator\";\n\nexport default class BracketToken extends GroupToken {\n    static isApplicable(character) {\n        return character === \"(\";\n    }\n\n    isChildAllowed() {\n        return this.getIterator().getValue() !== \")\";\n    }\n\n    transform() {\n        addMultiplicationOperator(this);\n    }\n\n    parse() {\n        const nextValue = this.getIterator().getNextValue();\n        // TODO I think we should not accept empty brackets  like 2 + ()*3 we should throw error in this condition\n        if (nextValue === \")\") {\n            throw SyntaxError(\"Empty brackets are not allowed\");\n        }\n        this.parseUp();\n        this.parseLeft();\n    }\n}\n","import GroupToken from \"./GroupToken\";\n\nexport default class ArgumentToken extends GroupToken {\n    static isApplicable(character) {\n        return character === \"(\";\n    }\n\n    isChildAllowed() {\n        return ![\")\", \",\"].includes(this.getIterator().getValue());\n    }\n\n    parse() {\n        this.parseUp();\n    }\n}\n","import GroupToken from \"./GroupToken\";\nimport addMultiplicationOperator from \"./transformModifier/addMultiplicationOperator\";\nimport BracketToken from \"./BracketToken\";\nimport ArgumentToken from \"./ArgumentToken\";\n\nexport default class VariableToken extends GroupToken {\n    static isApplicable(character) {\n        return /^[a-z]$/i.test(character);\n    }\n\n    constructor(iterator) {\n        super(iterator);\n        this.name = iterator.getValue();\n        this.isFunction = false;\n    }\n\n    setName(name) {\n        this.name = name;\n    }\n\n    getName() {\n        return this.name;\n    }\n\n    parseArguments() {\n        const nextValue = this.getIterator().getNextValue();\n        if (nextValue === \"(\") {\n            this.getIterator().moveLeft();\n            this.isFunction = true;\n            const nextValue = this.getIterator().getNextValue();\n            if (nextValue === \")\") {\n                this.getIterator().moveLeft();\n            } else {\n                while (true) {\n                    this.parseArgument();\n                    if (this.getIterator().getValue() !== \",\") {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    parseArgument() {\n        const argumentToken = new ArgumentToken(this.getIterator());\n        this.addChild(argumentToken);\n        argumentToken.setRoot(this.getRoot());\n        argumentToken.setParent(this);\n        argumentToken.parse();\n    }\n\n    parseName() {\n        while (true) {\n            const nextValue = this.getIterator().getNextValue();\n            if (/^[a-z0-9]$/i.test(nextValue)) {\n                this.getIterator().moveLeft();\n                this.setName(this.getName() + \"\" + nextValue);\n            } else {\n                break;\n            }\n        }\n    }\n\n    parse() {\n        this.parseName();\n        this.parseArguments();\n        this.parseLeft();\n    }\n\n    transform() {\n        /*\n        const rightOperand = this.getRight();\n        if (rightOperand && rightOperand instanceof BracketToken) {\n            this.isFunction = true;\n            const rightOperandSibling = rightOperand.getRight();\n            if(rightOperand.getParent()) {\n                rightOperand.getParent().removeChild(rightOperand);\n            }\n            rightOperand.getParent().removeChild(rightOperand);\n            rightOperand.setParent(this);\n            rightOperand.setLeft(null);\n            rightOperand.setRight(null);\n            if(rightOperandSibling) {\n                rightOperandSibling.setLeft(this);\n            }\n            this.addChild(rightOperand);\n        }\n        */\n        addMultiplicationOperator(this);\n    }\n\n    evaluate(declarations) {\n        const variableName = this.getName();\n        if (!declarations || !(variableName in declarations)) {\n            throw SyntaxError(`Expected variable is not defined ${variableName}`);\n        }\n        const variable = declarations[variableName];\n        if (typeof variable === \"function\") {\n            if (variable.length !== this.getNumChildren()) {\n                throw SyntaxError(\n                    `Expected number of arguments ${\n                        variable.length\n                    } but got ${this.getNumChildren()}`\n                );\n            }\n            const evaluatedArguments = this.getChildren().map(child =>\n                child.evaluate(declarations)\n            );\n            return Number(variable.apply({}, evaluatedArguments));\n        }\n        if (this.isFunction) {\n            throw SyntaxError(`Expected variable but got function ${variableName}`);\n        }\n        return Number(variable);\n    }\n}\n","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\nimport NumberToken from \"./NumberToken\";\n\nexport default class LeftNotNullRightOperatorToken extends LeftRightOperatorToken {\n\n    getLeftOperand() {\n        const operand = this.getLeft();\n        if(!operand) {\n            const numberToken = new NumberToken(this.getIterator());\n            numberToken.setValue(0);\n            return numberToken;\n        }\n        return operand;\n    }\n}","import LeftNotNullRightOperatorToken from \"./LeftNotNullRightOperatorToken\";\n\nexport default class AdditionToken extends LeftNotNullRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"+\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) + this.getRightChild().evaluate(declarations);\n    }\n}","import LeftRightOperatorToken from \"./LeftRightOperatorToken\";\n\n\nexport default class DivisionToken extends LeftRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"/\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) / this.getRightChild().evaluate(declarations);\n    }\n}","import LeftNotNullRightOperatorToken from \"./LeftNotNullRightOperatorToken\";\n\n\nexport default class SubtractionToken extends LeftNotNullRightOperatorToken {\n    static isApplicable(character) {\n        return character === \"-\";\n    }\n\n    evaluate(declarations) {\n        return this.getLeftChild().evaluate(declarations) - this.getRightChild().evaluate(declarations);\n    }\n}","import CharacterAccessor from \"./CharacterAccessor\";\nimport BaseToken from \"./tokens/AbstractToken\";\nimport RootToken from \"./tokens/RootToken\";\nimport NumberToken from \"./tokens/NumberToken\";\nimport VariableToken from \"./tokens/VariableToken\";\nimport BracketToken from \"./tokens/BracketToken\";\nimport AdditionToken from \"./tokens/AdditionToken\";\nimport DivisionToken from \"./tokens/DivisionToken\";\nimport MultiplicationToken from \"./tokens/MultiplicationToken\";\nimport SubtractionToken from \"./tokens/SubtractionToken\";\n\nBaseToken.registerTokenType(NumberToken);\nBaseToken.registerTokenType(VariableToken);\nBaseToken.registerTokenType(AdditionToken);\nBaseToken.registerTokenType(SubtractionToken);\nBaseToken.registerTokenType(DivisionToken);\nBaseToken.registerTokenType(MultiplicationToken);\nBaseToken.registerTokenType(BracketToken);\n\nexport default function lexer(stringExpression) {\n    const iterator = new CharacterAccessor(stringExpression);\n    iterator.removeCharacters(/\\s/g);\n    const rootToken = new RootToken(iterator);\n    rootToken.parse();\n    return rootToken;\n}\n","import lexer from \"./lexer\";\nimport transformer from \"./transformer\";\n\nclass EvalExp {\n    static evaluate(expression, declarations = {}) {\n        const evalExp = new EvalExp(expression);\n        return evalExp.evaluate(declarations);\n    }\n\n    constructor(expression) {\n        this.expression = expression;\n        this.rootToken = null;\n    }\n\n    parse() {\n        this.rootToken = lexer(this.expression);\n        transformer(this.rootToken);\n    }\n\n    getParsedTree() {\n        this.parseIfNotParsed();\n        return this.rootToken;\n    }\n\n    evaluate(declarations = {}) {\n        this.parseIfNotParsed();\n        return this.rootToken.evaluate(declarations);\n    }\n\n    parseIfNotParsed() {\n        if (!this.rootToken) {\n            this.parse();\n        }\n    }\n}\nfunction evaluate(expression, declarations) {\n    return EvalExp.evaluate(expression, declarations);\n}\n\nexport default EvalExp;\nexport { EvalExp, evaluate };\n","import MultiplicationToken from \"./tokens/MultiplicationToken\";\nimport DivisionToken from \"./tokens/DivisionToken\";\nimport AdditionToken from \"./tokens/AdditionToken\";\nimport SubtractionToken from \"./tokens/SubtractionToken\";\nimport VariableToken from \"./tokens/VariableToken\";\nimport BracketToken from \"./tokens/BracketToken\";\n\nexport default function transformer(rootToken) {\n    const orderedOperatorTypes = [\n        BracketToken,\n        VariableToken,\n        MultiplicationToken,\n        DivisionToken,\n        AdditionToken,\n        SubtractionToken\n    ];\n\n    const tokenList = rootToken.getGlobalList();\n    orderedOperatorTypes.forEach(operatorType => {\n        tokenList.forEach(token => {\n            if (token instanceof operatorType) {\n                token.transform();\n            }\n        });\n    });\n    return rootToken;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(426);\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}